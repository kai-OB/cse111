head	1.78;
access;
symbols;
locks;
comment	@// @;


1.78
date	2020.08.03.21.37.13;	author -;	state -;
branches;
next	1.77;

1.77
date	2020.08.03.21.29.04;	author -;	state -;
branches;
next	1.76;

1.76
date	2020.08.03.21.12.38;	author -;	state -;
branches;
next	1.75;

1.75
date	2020.08.03.20.17.31;	author -;	state -;
branches;
next	1.74;

1.74
date	2020.08.03.06.01.21;	author -;	state -;
branches;
next	1.73;

1.73
date	2020.08.03.06.00.12;	author -;	state -;
branches;
next	1.72;

1.72
date	2020.08.03.05.59.43;	author -;	state -;
branches;
next	1.71;

1.71
date	2020.08.03.05.59.25;	author -;	state -;
branches;
next	1.70;

1.70
date	2020.08.03.05.54.01;	author -;	state -;
branches;
next	1.69;

1.69
date	2020.08.03.05.50.57;	author -;	state -;
branches;
next	1.68;

1.68
date	2020.08.03.05.45.56;	author -;	state -;
branches;
next	1.67;

1.67
date	2020.08.03.05.29.24;	author -;	state -;
branches;
next	1.66;

1.66
date	2020.08.03.05.26.04;	author -;	state -;
branches;
next	1.65;

1.65
date	2020.08.03.05.18.51;	author -;	state -;
branches;
next	1.64;

1.64
date	2020.08.03.05.14.47;	author -;	state -;
branches;
next	1.63;

1.63
date	2020.08.03.05.10.41;	author -;	state -;
branches;
next	1.62;

1.62
date	2020.08.03.04.42.30;	author -;	state -;
branches;
next	1.61;

1.61
date	2020.08.03.04.39.23;	author -;	state -;
branches;
next	1.60;

1.60
date	2020.08.03.04.36.56;	author -;	state -;
branches;
next	1.59;

1.59
date	2020.08.03.04.36.33;	author -;	state -;
branches;
next	1.58;

1.58
date	2020.08.03.04.36.14;	author -;	state -;
branches;
next	1.57;

1.57
date	2020.08.03.00.36.26;	author -;	state -;
branches;
next	1.56;

1.56
date	2020.08.03.00.32.58;	author -;	state -;
branches;
next	1.55;

1.55
date	2020.07.26.00.38.34;	author -;	state -;
branches;
next	1.54;

1.54
date	2020.07.26.00.38.06;	author -;	state -;
branches;
next	1.53;

1.53
date	2020.07.26.00.36.10;	author -;	state -;
branches;
next	1.52;

1.52
date	2020.07.26.00.35.00;	author -;	state -;
branches;
next	1.51;

1.51
date	2020.07.26.00.34.26;	author -;	state -;
branches;
next	1.50;

1.50
date	2020.07.26.00.33.39;	author -;	state -;
branches;
next	1.49;

1.49
date	2020.07.26.00.11.43;	author -;	state -;
branches;
next	1.48;

1.48
date	2020.07.26.00.09.50;	author -;	state -;
branches;
next	1.47;

1.47
date	2020.07.26.00.08.29;	author -;	state -;
branches;
next	1.46;

1.46
date	2020.07.26.00.06.43;	author -;	state -;
branches;
next	1.45;

1.45
date	2020.07.26.00.04.35;	author -;	state -;
branches;
next	1.44;

1.44
date	2020.07.25.23.56.08;	author -;	state -;
branches;
next	1.43;

1.43
date	2020.07.25.23.55.42;	author -;	state -;
branches;
next	1.42;

1.42
date	2020.07.25.23.48.23;	author -;	state -;
branches;
next	1.41;

1.41
date	2020.07.25.23.47.49;	author -;	state -;
branches;
next	1.40;

1.40
date	2020.07.25.23.46.52;	author -;	state -;
branches;
next	1.39;

1.39
date	2020.07.25.23.39.15;	author -;	state -;
branches;
next	1.38;

1.38
date	2020.07.25.23.38.32;	author -;	state -;
branches;
next	1.37;

1.37
date	2020.07.25.23.36.37;	author -;	state -;
branches;
next	1.36;

1.36
date	2020.07.25.23.34.58;	author -;	state -;
branches;
next	1.35;

1.35
date	2020.07.25.23.34.32;	author -;	state -;
branches;
next	1.34;

1.34
date	2020.07.25.23.19.04;	author -;	state -;
branches;
next	1.33;

1.33
date	2020.07.25.23.15.06;	author -;	state -;
branches;
next	1.32;

1.32
date	2020.07.25.23.14.06;	author -;	state -;
branches;
next	1.31;

1.31
date	2020.07.25.23.12.09;	author -;	state -;
branches;
next	1.30;

1.30
date	2020.07.25.23.05.20;	author -;	state -;
branches;
next	1.29;

1.29
date	2020.07.25.22.36.44;	author -;	state -;
branches;
next	1.28;

1.28
date	2020.07.25.22.35.54;	author -;	state -;
branches;
next	1.27;

1.27
date	2020.07.25.22.33.08;	author -;	state -;
branches;
next	1.26;

1.26
date	2020.07.25.22.32.29;	author -;	state -;
branches;
next	1.25;

1.25
date	2020.07.25.22.32.03;	author -;	state -;
branches;
next	1.24;

1.24
date	2020.07.25.22.30.39;	author -;	state -;
branches;
next	1.23;

1.23
date	2020.07.25.22.28.12;	author -;	state -;
branches;
next	1.22;

1.22
date	2020.07.25.22.20.14;	author -;	state -;
branches;
next	1.21;

1.21
date	2020.07.25.22.19.44;	author -;	state -;
branches;
next	1.20;

1.20
date	2020.07.25.22.19.04;	author -;	state -;
branches;
next	1.19;

1.19
date	2020.07.25.22.18.35;	author -;	state -;
branches;
next	1.18;

1.18
date	2020.07.25.22.15.34;	author -;	state -;
branches;
next	1.17;

1.17
date	2020.07.25.22.14.31;	author -;	state -;
branches;
next	1.16;

1.16
date	2020.07.25.22.12.29;	author -;	state -;
branches;
next	1.15;

1.15
date	2020.07.25.22.09.35;	author -;	state -;
branches;
next	1.14;

1.14
date	2020.07.25.22.05.38;	author -;	state -;
branches;
next	1.13;

1.13
date	2020.07.25.22.03.32;	author -;	state -;
branches;
next	1.12;

1.12
date	2020.07.25.21.54.52;	author -;	state -;
branches;
next	1.11;

1.11
date	2020.07.25.21.52.15;	author -;	state -;
branches;
next	1.10;

1.10
date	2020.07.25.21.50.51;	author -;	state -;
branches;
next	1.9;

1.9
date	2020.07.25.21.11.09;	author -;	state -;
branches;
next	1.8;

1.8
date	2020.07.25.21.08.36;	author -;	state -;
branches;
next	1.7;

1.7
date	2020.07.25.21.07.39;	author -;	state -;
branches;
next	1.6;

1.6
date	2019.03.22.00.00.11;	author -;	state -;
branches;
next	1.5;

1.5
date	2019.03.21.23.59.33;	author -;	state -;
branches;
next	1.4;

1.4
date	2019.03.21.23.58.50;	author -;	state -;
branches;
next	1.3;

1.3
date	2019.03.21.23.56.44;	author -;	state -;
branches;
next	1.2;

1.2
date	2019.03.21.23.56.08;	author -;	state -;
branches;
next	1.1;

1.1
date	2019.03.21.23.53.14;	author -;	state -;
branches;
next	;


desc
@@


1.78
log
@-
@
text
@// $Id: glclock.cpp,v 1.77 2020-08-03 14:29:04-07 - - $

// Show a real-time analog clock.

#include <cassert>
#include <cmath>
#include <cstring>
#include <iostream>
using namespace std;

#define GL_SILENCE_DEPRECATION

#include <GL/freeglut.h>
#include <libgen.h>
#include <sys/time.h>
#include <time.h>
#include <unistd.h>

static const GLubyte FOREGROUND[] = {0x00, 0xFF, 0x00};
static constexpr float RADIUS = 0.9;

struct {
   string program_name;
   int width = 256;
   int height = 256;
   bool minutes_only = false;
   bool smooth_ticks = false;
   bool fractional_seconds = false;
   unsigned int frequency_msec() {
      return smooth_ticks ? 50 : 500;
   }
} window;

struct calendar {
   time_t clock;
   struct tm localtime;
   struct timeval timevalue;
   double seconds;
   char sdate[64];
   char stime[64];
   void set() {
      clock = time (nullptr);
      localtime_r (&clock, &localtime);
      strftime (sdate, sizeof sdate, "%a %b %e", &localtime);
      if (window.fractional_seconds) {
         strftime (stime, sizeof stime, "%T.", &localtime);
         char frac[16];
         snprintf (frac, sizeof frac, "%06zd", timevalue.tv_usec);
         frac[1] = '\0';
         strncat (stime, frac, sizeof stime);
      }else {
         const char* timefmt = window.minutes_only
                             ?  "%I:%M %p" : "%I:%M:%S %p";
         strftime (stime, sizeof stime, timefmt, &localtime);
         if (stime[0] == '0') stime[0] = ' ';
         for (char* chr = stime; *chr != '\0'; ++chr) {
            if (isupper(*chr)) *chr = tolower (*chr);
         }
      }
      gettimeofday (&timevalue, nullptr);
      seconds = double (timevalue.tv_sec % 60)
              + double (timevalue.tv_usec) / 1.0e6;
   }
} calendar;

const GLubyte* ubytes (const char* cstring) {
   return reinterpret_cast<const GLubyte*> (cstring);
}

void draw_time() {
   void* font = GLUT_BITMAP_HELVETICA_18;
   float text_xmargin = 0.95;
   float text_ymargin = 0.925;
   float font_height = glutBitmapHeight (font);
   float time_ypos = text_ymargin - font_height / window.height;
   glRasterPos2f (-text_xmargin, time_ypos);
   glutBitmapString (font, ubytes (calendar.sdate));
   float time_width = glutBitmapLength (font, ubytes (calendar.stime));
   float time_xpos = text_xmargin - 2 * time_width / window.width;
   glRasterPos2f (time_xpos, time_ypos);
   glutBitmapString (font, ubytes (calendar.stime));
}

void draw_dots (int points, int count) {
   glEnable (GL_POINT_SMOOTH);
   glPointSize (points);
   glBegin(GL_POINTS);
   glColor3ubv (FOREGROUND);
   for (float theta = 0; theta < 2 * M_PI; theta += 2 * M_PI / count) {
      float xdot = 0.9 * RADIUS * cos (theta);
      float ydot = 0.9 * RADIUS * sin (theta);
      glVertex2f (xdot, ydot);
   }
   glEnd();
}

void draw_hand (GLfloat width, GLfloat length, GLfloat clock) {
   glEnable (GL_LINE_SMOOTH);
   glEnable (GL_POLYGON_SMOOTH);
   glPushMatrix();
   glRotatef (-clock * 6, 0, 0, 1);
   glColor3ubv (FOREGROUND);
   glBegin (GL_POLYGON);
   glVertex2f (-width / 2 * RADIUS, -0.05);
   glVertex2f (+width / 2 * RADIUS, -0.05);
   glVertex2f (+width / 4, length * RADIUS);
   glVertex2f (-width / 4, length * RADIUS);
   glEnd();
   glPopMatrix();
}

void display() {
   glClear (GL_COLOR_BUFFER_BIT);
   glColor3ubv (FOREGROUND);
   draw_dots (4, 60);
   draw_dots (10, 12);
   calendar.set();
   float second = calendar.localtime.tm_sec;
   float minute = calendar.localtime.tm_min + second / 60;
   float hour = calendar.localtime.tm_hour + minute / 60;
   draw_hand (0.1, 0.6, hour * 5);
   draw_hand (0.075, 0.8, minute);
   if (not window.minutes_only) {
      if (window.smooth_ticks) draw_hand (0.05, 1.0, calendar.seconds);
                          else draw_hand (0.05, 1.0, second);
   }
   draw_time();
   glutSwapBuffers();
}

void timer (int) {
   glutTimerFunc (window.frequency_msec(), timer, 0);
   glutPostRedisplay();
}

void reshape (int width, int height) {
   window.width = width;
   window.height = height;
   glMatrixMode (GL_PROJECTION);
   glLoadIdentity();
   gluOrtho2D (-1, +1, -1, +1);
   glMatrixMode (GL_MODELVIEW);
   glHint (GL_POINT_SMOOTH_HINT, GL_NICEST);
   glHint (GL_LINE_SMOOTH_HINT, GL_NICEST);
   glHint (GL_POLYGON_SMOOTH_HINT, GL_NICEST);
   glViewport (0, 0, window.width, window.height);
   glClearColor (0x1Fp0/255, 0x1Fp0/255, 0x1Fp0/255, 1.0);
}

void usage_exit() {
   cerr << "Usage: " << window.program_name
                     << " [-mps] [-w size]" << endl;
   cerr << "-f fractional seconds" << endl;
   cerr << "-m minutes only" << endl;
   cerr << "-s smooth second hand" << endl;
   cerr << "-w window size (pixels)" << endl;
   exit (EXIT_FAILURE);
}

void scan_options (int argc, char** argv) {
   bool invalid_opt = false;
   for (;;) {
      int opt = getopt (argc, argv, "fmsw:");
      if (opt == EOF) break;
      switch (opt) {
         case 'f': window.fractional_seconds = true;
                   window.smooth_ticks = true;
                   break;
         case 'm': window.minutes_only = true;
                   break;
         case 's': window.smooth_ticks = true;
                   break;
         case 'w': window.width = window.height = atoi (optarg);
                   break;
         default:  invalid_opt = true;
      }
   }
   if (invalid_opt) usage_exit();
   if ((window.fractional_seconds || window.smooth_ticks)
       && window.minutes_only) {
      cerr << window.program_name
           << ": -m option is incompatible with -f or -s" << endl;
      usage_exit();
   }
}

int main (int argc, char** argv) {
   window.program_name = basename (argv[0]);
   scan_options (argc, argv);
   glutInit (&argc, argv);
   glutInitDisplayMode (GLUT_RGBA | GLUT_DOUBLE);
   glutInitWindowSize (window.width, window.height);
   glutCreateWindow (window.program_name.c_str());
   glutDisplayFunc (display);
   glutReshapeFunc (reshape);
   glutTimerFunc (window.frequency_msec(), timer, 0);
   glutMainLoop();
   return EXIT_SUCCESS;
}

//TEST// mkpspdf glclock.ps glclock.cpp*

@


1.77
log
@-
@
text
@d1 1
a1 1
// $Id: glclock.cpp,v 1.76 2020-08-03 14:12:38-07 - - $
a33 1

a83 1

a135 1

@


1.76
log
@-
@
text
@d1 1
a1 1
// $Id: glclock.cpp,v 1.75 2020-08-03 13:17:31-07 - - $
d164 1
d178 1
a178 1
         default:  usage_exit();
d181 1
@


1.75
log
@-
@
text
@d1 1
a1 1
// $Id: glclock.cpp,v 1.74 2020-08-02 23:01:21-07 - - $
d71 1
a71 1
void show_time() {
d129 1
a129 1
   show_time();
a157 1
   cerr << "-p pointy clock hands" << endl;
@


1.74
log
@-
@
text
@d1 1
a1 1
// $Id: glclock.cpp,v 1.73 2020-08-02 23:00:12-07 - - $
d39 1
a39 1
   float seconds;
@


1.73
log
@-
@
text
@d1 1
a1 1
// $Id: glclock.cpp,v 1.72 2020-08-02 22:59:43-07 - - $
d140 2
a141 1
   window.width = window.height = (width + height) / 2;;
@


1.72
log
@-
@
text
@d1 1
a1 1
// $Id: glclock.cpp,v 1.71 2020-08-02 22:59:25-07 - - $
d20 1
a20 1
static const float RADIUS = 0.9;
@


1.71
log
@-
@
text
@d1 1
a1 1
// $Id: glclock.cpp,v 1.70 2020-08-02 22:54:01-07 - - $
d20 1
a20 1
static constexpr float RADIUS = 0.9;
@


1.70
log
@-
@
text
@d1 1
a1 1
// $Id: glclock.cpp,v 1.69 2020-08-02 22:50:57-07 - - $
d140 1
a140 2
   window.width = width;
   window.height = height;
@


1.69
log
@-
@
text
@d1 1
a1 1
// $Id: glclock.cpp,v 1.68 2020-08-02 22:45:56-07 - - $
a26 1
   bool pointy_hands = false;
d108 2
a109 6
   if (window.pointy_hands) {
      glVertex2f (0, length * RADIUS);
   }else {
      glVertex2f (+width / 4, length * RADIUS);
      glVertex2f (-width / 4, length * RADIUS);
   }
d166 1
a166 1
      int opt = getopt (argc, argv, "fmpsw:");
a172 2
                   break;
         case 'p': window.pointy_hands = true;
@


1.68
log
@-
@
text
@d1 1
a1 1
// $Id: glclock.cpp,v 1.66 2020-08-02 22:26:04-07 - - $
d19 3
a34 4

static const GLubyte FOREGROUND[] = {0x00, 0xFF, 0x00};
static constexpr float RADIUS = 0.9;

d149 1
a149 1
   gluOrtho2D (-width / 2, +width / 2, -height / 2, +height / 2);
@


1.67
log
@-
@
text
@d1 1
a1 1
// $Id: glclock.cpp,v 1.65 2020-08-02 22:18:51-07 - - $
a18 2
static const GLubyte FOREGROUND[] = {0x00, 0xFF, 0x00};

a26 3
   float radius() {
      return 0.9 * min (width, height);
   }
d32 5
d87 1
d94 2
a95 2
      float xdot = 0.9 * window.radius() * cos (theta);
      float ydot = 0.9 * window.radius() * sin (theta);
d108 2
a109 2
   glVertex2f (-width / 2 * window.radius(), -0.05);
   glVertex2f (+width / 2 * window.radius(), -0.05);
d111 1
a111 1
      glVertex2f (0, length * window.radius());
d113 2
a114 2
      glVertex2f (+width / 4, length * window.radius());
      glVertex2f (-width / 4, length * window.radius());
@


1.66
log
@-
@
text
@d19 2
d29 3
a36 5

static const GLubyte FOREGROUND[] = {0x00, 0xFF, 0x00};
static constexpr float RADIUS = 0.9;


a86 1

d93 2
a94 2
      float xdot = 0.9 * RADIUS * cos (theta);
      float ydot = 0.9 * RADIUS * sin (theta);
d107 2
a108 2
   glVertex2f (-width / 2 * RADIUS, -0.05);
   glVertex2f (+width / 2 * RADIUS, -0.05);
d110 1
a110 1
      glVertex2f (0, length * RADIUS);
d112 2
a113 2
      glVertex2f (+width / 4, length * RADIUS);
      glVertex2f (-width / 4, length * RADIUS);
@


1.65
log
@-
@
text
@d1 1
a1 1
// $Id: glclock.cpp,v 1.64 2020-08-02 22:14:47-07 - - $
d150 1
a150 1
   gluOrtho2D (-1, +1, -1, +1);
@


1.64
log
@-
@
text
@d1 1
a1 1
// $Id: glclock.cpp,v 1.62 2020-08-02 21:42:30-07 - - $
a188 2
   cout << "if ((" << (window.fractional_seconds || window.smooth_ticks)
       << window.minutes_only << endl;
@


1.63
log
@-
@
text
@d1 1
a1 1
// $Id: glclock.cpp,v 1.61 2020-08-02 21:39:23-07 - - $
a18 2
static const GLubyte FOREGROUND[] = {0x00, 0xFF, 0x00};

a29 3
   float radius() {
      return 0.9 * min (width, height);
   }
d32 4
d94 2
a95 2
      float xdot = 0.9 * window.radius() * cos (theta);
      float ydot = 0.9 * window.radius() * sin (theta);
d108 2
a109 2
   glVertex2f (-width / 2 * window.radius(), -0.05);
   glVertex2f (+width / 2 * window.radius(), -0.05);
d111 1
a111 1
      glVertex2f (0, length * window.radius());
d113 2
a114 2
      glVertex2f (+width / 4, length * window.radius());
      glVertex2f (-width / 4, length * window.radius());
d189 2
@


1.62
log
@-
@
text
@d19 2
d32 3
a36 4

static const GLubyte FOREGROUND[] = {0x00, 0xFF, 0x00};
static constexpr float RADIUS = 0.9;

d95 2
a96 2
      float xdot = 0.9 * RADIUS * cos (theta);
      float ydot = 0.9 * RADIUS * sin (theta);
d109 2
a110 2
   glVertex2f (-width / 2 * RADIUS, -0.05);
   glVertex2f (+width / 2 * RADIUS, -0.05);
d112 1
a112 1
      glVertex2f (0, length * RADIUS);
d114 2
a115 2
      glVertex2f (+width / 4, length * RADIUS);
      glVertex2f (-width / 4, length * RADIUS);
a189 2
   cout << "if ((" << (window.fractional_seconds || window.smooth_ticks)
       << window.minutes_only << endl;
@


1.61
log
@-
@
text
@d1 1
a1 1
// $Id: glclock.cpp,v 1.60 2020-08-02 21:36:56-07 - - $
d189 2
@


1.60
log
@-
@
text
@d1 1
a1 1
// $Id: glclock.cpp,v 1.59 2020-08-02 21:36:33-07 - - $
d192 2
a193 1
           << ": -m option is incompatible with -f and -s" << endl;
@


1.59
log
@-
@
text
@d1 1
a1 1
// $Id: glclock.cpp,v 1.58 2020-08-02 21:36:14-07 - - $
d190 1
a190 1
       && window.munutes_only) {
@


1.58
log
@-
@
text
@d1 1
a1 1
// $Id: glclock.cpp,v 1.57 2020-08-02 17:36:26-07 - - $
d190 1
a190 1
       && window.munutes_only) { &&
@


1.57
log
@-
@
text
@d1 1
a1 1
// $Id: glclock.cpp,v 1.56 2020-08-02 17:32:58-07 - - $
d159 11
d173 1
a174 1
         case EOF: return;
d186 1
a186 8
         default: cerr << "Usage: " << window.program_name
                       << " [-mps] [-w size]" << endl;
                  cerr << "-f fractional seconds" << endl;
                  cerr << "-m minutes only" << endl;
                  cerr << "-p pointy clock hands" << endl;
                  cerr << "-s smooth second hand" << endl;
                  cerr << "-w window size (pixels)" << endl;
                  exit (EXIT_FAILURE);
d188 5
@


1.56
log
@-
@
text
@d1 1
a1 1
// $Id: glclock.cpp,v 1.55 2020-07-25 17:38:34-07 - - $
d176 6
a181 1
                       << " -mps -w size" << endl;
@


1.55
log
@-
@
text
@d1 1
a1 1
// $Id: glclock.cpp,v 1.54 2020-07-25 17:38:06-07 - - $
d36 1
@


1.54
log
@-
@
text
@d1 1
a1 1
// $Id: glclock.cpp,v 1.53 2020-07-25 17:36:10-07 - - $
d51 1
a51 1
         frac[2] = '\0';
@


1.53
log
@-
@
text
@d1 1
a1 1
// $Id: glclock.cpp,v 1.52 2020-07-25 17:35:00-07 - - $
d49 4
a52 3
         char buf[16];
         snprintf (buf, sizeof buf, "%02zd", timevalue.tv_usec / 10000);
         strncat (stime, buf, sizeof stime);
@


1.52
log
@-
@
text
@d1 1
a1 1
// $Id: glclock.cpp,v 1.51 2020-07-25 17:34:26-07 - - $
d51 1
a51 1
         strncat (stime, sizeof stime, buf);
@


1.51
log
@-
@
text
@d1 1
a1 1
// $Id: glclock.cpp,v 1.50 2020-07-25 17:33:39-07 - - $
d7 1
d47 1
a47 1
      if (fractional_seconds) {
@


1.50
log
@-
@
text
@d1 1
a1 1
// $Id: glclock.cpp,v 1.49 2020-07-25 17:11:43-07 - - $
d49 2
a50 1
         snprintf (buf, sizeof buf, "%02d", timevalue.tv_usec / 10000);                strncat (stime, sizeof stime, buf);
@


1.49
log
@-
@
text
@d1 1
a1 1
// $Id: glclock.cpp,v 1.48 2020-07-25 17:09:50-07 - - $
d25 1
d46 12
a57 6
      const char* timefmt = window.minutes_only
                          ?  "%I:%M %p" : "%I:%M:%S %p";
      strftime (stime, sizeof stime, timefmt, &localtime);
      if (stime[0] == '0') stime[0] = ' ';
      for (char* chr = stime; *chr != '\0'; ++chr) {
         if (isupper(*chr)) *chr = tolower (*chr);
d157 1
a157 1
      int opt = getopt (argc, argv, "mpsw:");
d160 3
@


1.48
log
@-
@
text
@d1 1
a1 1
// $Id: glclock.cpp,v 1.47 2020-07-25 17:08:29-07 - - $
d161 3
a163 1
         default: assert (false);
d179 1
a179 1
   return 0;
@


1.47
log
@-
@
text
@d1 1
a1 1
// $Id: glclock.cpp,v 1.46 2020-07-25 17:06:43-07 - - $
d53 1
a53 2
      assert (timevalue.tv_sec % 60 == localtime.tm_sec);
      seconds = double (timevalue.tv_sec)
@


1.46
log
@-
@
text
@d1 1
a1 1
// $Id: glclock.cpp,v 1.45 2020-07-25 17:04:35-07 - - $
d54 2
a55 1
      seconds = localtime.tm_sec + double (timevalue.tv_usec) / 1.0e6;
@


1.45
log
@-
@
text
@d1 1
a1 1
// $Id: glclock.cpp,v 1.44 2020-07-25 16:56:08-07 - - $
d121 2
a122 1
      draw_hand (0.05, 1.0, second);
@


1.44
log
@-
@
text
@d1 1
a1 1
// $Id: glclock.cpp,v 1.43 2020-07-25 16:55:42-07 - - $
d18 1
a18 1
struct window {
d24 4
a27 1
   static constexpr unsigned int frequency_msec = 500;
d120 3
a122 1
   if (not window.minutes_only) draw_hand (0.05, 1.0, calendar.seconds);
d128 1
a128 1
   glutTimerFunc (window.frequency_msec, timer, 0);
d156 2
d174 1
a174 1
   glutTimerFunc (window.frequency_msec, timer, 0);
@


1.43
log
@-
@
text
@d1 1
a1 1
// $Id: glclock.cpp,v 1.42 2020-07-25 16:48:23-07 - - $
d117 1
a117 1
   if (not window.minutes_only) draw_hand (0.05, 1.0, calendar.second);
@


1.42
log
@-
@
text
@d1 1
a1 1
// $Id: glclock.cpp,v 1.41 2020-07-25 16:47:49-07 - - $
d31 1
a31 1
struct calend {
d35 1
d51 1
d53 1
a53 1
} calend;
d55 1
a55 1
const GLubyte* to_ubytes (const char* cstring) {
d66 2
a67 2
   glutBitmapString (font, to_ubytes (calend.sdate));
   float time_width = glutBitmapLength (font, to_ubytes (calend.stime));
d70 1
a70 1
   glutBitmapString (font, to_ubytes (calend.stime));
d111 4
a114 4
   calend.set();
   float second = calend.localtime.tm_sec;
   float minute = calend.localtime.tm_min + second / 60;
   float hour = calend.localtime.tm_hour + minute / 60;
d117 1
a117 1
   if (not window.minutes_only) draw_hand (0.05, 1.0, second);
@


1.41
log
@-
@
text
@d1 1
a1 1
// $Id: glclock.cpp,v 1.40 2020-07-25 16:46:52-07 - - $
d48 1
a48 1
      gettimeofday (&timevalue);
@


1.40
log
@-
@
text
@d1 1
a1 1
// $Id: glclock.cpp,v 1.39 2020-07-25 16:39:15-07 - - $
d14 1
@


1.39
log
@-
@
text
@d1 1
a1 1
// $Id: glclock.cpp,v 1.38 2020-07-25 16:38:32-07 - - $
d33 1
d47 2
a125 1
   cout << "reshape(width=" << width << ", height=" << height << endl;
@


1.38
log
@-
@
text
@d1 1
a1 1
// $Id: glclock.cpp,v 1.37 2020-07-25 16:36:37-07 - - $
d17 1
a17 1
struct {
@


1.37
log
@-
@
text
@d1 1
a1 1
// $Id: glclock.cpp,v 1.36 2020-07-25 16:34:58-07 - - $
d23 1
a23 1
   constexpr float frequency_msec = 500;
@


1.36
log
@-
@
text
@d1 1
a1 1
// $Id: glclock.cpp,v 1.35 2020-07-25 16:34:32-07 - - $
d23 1
a23 4
   float frequency_msec = 500;
   void smooth_ticks (bool smooth) {
      frequency_msec = smooth ? 50 : 500;
   }
a144 2
                   break;
         case 's': window.smooth_ticks (true);
@


1.35
log
@-
@
text
@d1 1
a1 1
// $Id: glclock.cpp,v 1.34 2020-07-25 16:19:04-07 - - $
d24 1
a24 1
   bool smooth_ticks (bool smooth) {
@


1.34
log
@-
@
text
@d1 1
a1 1
// $Id: glclock.cpp,v 1.33 2020-07-25 16:15:06-07 - - $
d23 4
a118 1
const float frequency_msec = 500;
d120 1
a120 1
   glutTimerFunc (frequency_msec, timer, 100);
d142 1
a142 1
      int opt = getopt (argc, argv, "mpw:");
d149 2
d167 1
a167 1
   glutTimerFunc (frequency_msec, timer, 100);
@


1.33
log
@-
@
text
@d1 1
a1 1
// $Id: glclock.cpp,v 1.32 2020-07-25 16:14:06-07 - - $
d22 1
a22 1
   bool blunt_hand_points = false;
d89 3
a91 1
   if (window.blunt_hand_points) {
a93 2
   }else {
      glVertex2f (0, length * RADIUS);
d139 1
a139 1
      int opt = getopt (argc, argv, "bmw:");
d142 1
a142 1
         case 'b': window.blunt_hand_points = true;
d144 1
a144 1
         case 'm': window.minutes_only = true;
@


1.32
log
@-
@
text
@d1 1
a1 1
// $Id: glclock.cpp,v 1.31 2020-07-25 16:12:09-07 - - $
d90 2
a91 2
      glVertex2f (+width / 3, length * RADIUS);
      glVertex2f (-width / 3, length * RADIUS);
@


1.31
log
@-
@
text
@d1 1
a1 1
// $Id: glclock.cpp,v 1.30 2020-07-25 16:05:20-07 - - $
d87 2
a88 2
   glVertex2f (-width / 2 * RADIUS, -5);
   glVertex2f (+width / 2 * RADIUS, -5);
@


1.30
log
@-
@
text
@d1 1
a1 1
// $Id: glclock.cpp,v 1.29 2020-07-25 15:36:44-07 - - $
d60 3
a62 3
   float timewidth = glutBitmapLength (font, to_ubytes (calend.stime));
   float timexpos = text_xmargin - 2 * timewidth / window.width;
   glRasterPos2f (timexpos, time_ypos);
d87 2
a88 2
   glVertex2f (-width / 2 * RADIUS, 0);
   glVertex2f (+width / 2 * RADIUS, 0);
d90 2
a91 2
      glVertex2f (+width / 2, length * RADIUS);
      glVertex2f (-width / 2, length * RADIUS);
@


1.29
log
@-
@
text
@d1 1
a1 1
// $Id: glclock.cpp,v 1.28 2020-07-25 15:35:54-07 - - $
d10 2
a16 2
#define GL_SILENCE_DEPRECATION

d22 1
a26 1
static constexpr bool BLUNT_HAND_POINT = false;
d89 3
a91 3
   if (BLUNT_HAND_POINT) {
      glVertex2f (+width / 8, length * RADIUS);
      glVertex2f (-width / 8, length * RADIUS);
d139 1
a139 1
      int opt = getopt (argc, argv, "mw:");
d142 2
@


1.28
log
@-
@
text
@d1 1
a1 1
// $Id: glclock.cpp,v 1.27 2020-07-25 15:33:08-07 - - $
d55 1
a55 1
   float text_ymargin = 0.90;
@


1.27
log
@-
@
text
@d1 1
a1 1
// $Id: glclock.cpp,v 1.26 2020-07-25 15:32:29-07 - - $
d54 5
a58 4
   float text_margin = 0.95;
   float text_height = glutBitmapHeight (font);
   float time_ypos = text_margin - text_height / window.height;
   glRasterPos2f (-text_margin, time_ypos);
d61 1
a61 1
   float timexpos = text_margin - 2 * timewidth / window.width;
@


1.26
log
@-
@
text
@d1 1
a1 1
// $Id: glclock.cpp,v 1.25 2020-07-25 15:32:03-07 - - $
d57 1
a57 1
   glRasterPos2f (-text_margin time_ypos);
@


1.25
log
@-
@
text
@d1 1
a1 1
// $Id: glclock.cpp,v 1.24 2020-07-25 15:30:39-07 - - $
d54 1
a54 1
   float text_margin = 0.95
@


1.24
log
@-
@
text
@d1 1
a1 1
// $Id: glclock.cpp,v 1.19 2020-07-25 15:18:35-07 - - $
d54 4
a57 4
   float margin = 0.95
   float height = glutBitmapHeight (font);
   float time_ypos = margin - height / window.height;
   glRasterPos2f (-margin time_ypos);
d60 1
a60 1
   float timexpos = margin - 2 * timewidth / window.width;
@


1.23
log
@-
@
text
@d54 1
d56 2
a57 2
   float time_ypos = +0.95 - height / window.height;
   glRasterPos2f (-0.95, time_ypos);
d60 1
a60 1
   float timexpos = 0.95 - 2 * timewidth / window.width;
@


1.22
log
@-
@
text
@d54 2
a55 1
   float time_ypos = +0.95 - glutBitmapHeight (font);;
@


1.21
log
@-
@
text
@d53 1
a53 1
   static const void* font = GLUT_BITMAP_HELVETICA_18;
@


1.20
log
@-
@
text
@d54 1
a54 1
   float time_ypos = +0.95 - glutBitMapHeight (font);;
@


1.19
log
@-
@
text
@d1 1
a1 1
// $Id: glclock.cpp,v 1.18 2020-07-25 15:15:34-07 - - $
d54 1
a54 1
   float time_ypos = +0.95 - glutBitMspHeight (font);;
@


1.18
log
@-
@
text
@d1 1
a1 1
// $Id: glclock.cpp,v 1.17 2020-07-25 15:14:31-07 - - $
d53 3
a55 2
   void* font = GLUT_BITMAP_HELVETICA_18;
   glRasterPos2f (-0.95, +0.95);
d59 1
a59 1
   glRasterPos2f (timexpos, +0.95);
@


1.17
log
@-
@
text
@d1 1
a1 1
// $Id: glclock.cpp,v 1.16 2020-07-25 15:12:29-07 - - $
d54 1
a54 1
   glRasterPos2f (-0.95, -0.95);
d58 1
a58 1
   glRasterPos2f (timexpos, -0.95);
@


1.16
log
@-
@
text
@d1 1
a1 1
// $Id: glclock.cpp,v 1.15 2020-07-25 15:09:35-07 - - $
d54 1
a54 1
   glRasterPos2f (-0.95, -0.05);
d58 1
a58 1
   glRasterPos2f (timexpos, -0.05);
@


1.15
log
@-
@
text
@d1 1
a1 1
// $Id: glclock.cpp,v 1.14 2020-07-25 15:05:38-07 - - $
d54 1
a54 1
   glRasterPos2f (-0.90, -0.90);
d57 2
a58 2
   float timexpos = 0.90 - 2 * timewidth / window.width;
   glRasterPos2f (timexpos, -.90);
@


1.14
log
@-
@
text
@d1 1
a1 1
// $Id: glclock.cpp,v 1.13 2020-07-25 15:03:32-07 - - $
d54 1
a54 1
   glRasterPos2f (-0.95, -0.95);
d57 2
a58 2
   float timexpos = 0.95 - 2 * timewidth / window.width;
   glRasterPos2f (timexpos, -.95);
@


1.13
log
@-
@
text
@d1 1
a1 1
// $Id: glclock.cpp,v 1.10 2020-07-25 14:50:51-07 - - $
d5 1
d138 2
a139 1
         case 'm': window.minutes_only = true; break;
d141 2
@


1.12
log
@-
@
text
@d132 1
a132 1
void scan_options() {
d134 1
a134 1
      int opt = getopt (argc, argv, "sw:");
d137 2
a138 2
         case 's': window.want_seconds = true; break;
         case 'w': window.width = window.height = optarg;
d145 1
a145 1
   scan_options();
@


1.11
log
@-
@
text
@d37 2
a38 1
      const char* timefmt = minutes_only ?  "%I:%M %p" : "%I:%M:%S %p";
d105 1
a105 1
   if (not minutes_only) draw_hand (0.05, 1.0, second);
d144 1
a144 1
   program_name = basename (argv[0]);
d149 1
a149 1
   glutCreateWindow (program_name.c_str());
@


1.10
log
@-
@
text
@d1 1
a1 1
// $Id: glclock.cpp,v 1.9 2020-07-25 14:11:09-07 - - $
d17 1
d20 1
a22 2
bool minutes_only = false;
string program_name;
@


1.9
log
@-
@
text
@d1 1
a1 1
// $Id: glclock.cpp,v 1.8 2020-07-25 14:08:36-07 - - $
d131 11
d144 1
a144 5
   for (;;) {
      int opt = getopt (argc, argv, "m");
      if (opt == EOF) break;
      if (opt == 's') minutes_only = true;
   }
@


1.8
log
@-
@
text
@d1 1
a1 1
// $Id: glclock.cpp,v 1.7 2020-07-25 14:07:39-07 - - $
d14 1
a14 1
bool minutes_only = false;
d21 1
d23 2
d26 1
a26 2
static const float RADIUS = 0.9;
static const GLubyte FOREGROUND[] = {0x00, 0xFF, 0x00};
@


1.7
log
@-
@
text
@d1 1
a1 1
// $Id: glclock.cpp,v 1.6 2019-03-21 17:00:11-07 - - $
d22 1
a22 1
static constexpr BLUNT_HAND_POINT = false;
@


1.6
log
@-
@
text
@d1 1
a1 1
// $Id: glclock.cpp,v 1.5 2019-03-21 16:59:33-07 - - $
d12 3
d22 1
d24 1
a24 1
static const GLubyte FOREGROUND[] {0x00, 0x00, 0xFF};
d35 2
a36 1
      strftime (stime, sizeof stime, "%I:%M:%S %p", &localtime);
d81 6
a86 2
   glVertex2f (+width / 8, length * RADIUS);
   glVertex2f (-width / 8, length * RADIUS);
d95 1
a95 1
   draw_dots (8, 12);
d102 1
a102 1
   draw_hand (0.05, 1.0, second);
d126 1
a126 1
   glClearColor (0xFFp0/255, 0xFFp0/255, 0x0Fp0/255, 1.0);
d131 5
@


1.5
log
@-
@
text
@d1 1
a1 1
// $Id: glclock.cpp,v 1.3 2019-03-21 16:56:44-07 - - $
d74 2
a75 2
   glVertex2f (-width / 2 * RADIUS, -2);
   glVertex2f (+width / 2 * RADIUS, -2);
@


1.4
log
@-
@
text
@d74 4
a77 3
   glVertex2f (-width / 2 * RADIUS, 0);
   glVertex2f (+width / 2 * RADIUS, 0);
   glVertex2f (0, length * RADIUS);
@


1.3
log
@-
@
text
@d1 1
a1 1
// $Id: glclock.cpp,v 1.2 2019-03-21 16:56:08-07 - - $
d76 1
a76 2
   glVertex2f (+width / 8, length * RADIUS);
   glVertex2f (-width / 8, length * RADIUS);
@


1.2
log
@-
@
text
@d1 1
a1 1
// $Id: glclock.cpp,v 1.1 2019-03-21 16:53:14-07 - - $
d91 2
a92 2
   draw_hand (0.1, 0.5, hour * 5);
   draw_hand (0.075, 0.75, minute);
@


1.1
log
@-
@
text
@d1 1
a1 1
// $Id: glclock.cpp,v 1.21 2019-03-20 13:14:35-07 - - $
d93 1
a93 1
   draw_hand (0.05, 0.95, second);
@
